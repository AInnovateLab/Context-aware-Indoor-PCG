import json
import math
from functools import partial

import torch


def load_config(file):
    config = json.load(file)
    return config


def make_sample_density(config):
    sd_config = config["sigma_sample_density"]
    sigma_data = config["sigma_data"]
    if sd_config["type"] == "lognormal":
        loc = sd_config["mean"] if "mean" in sd_config else sd_config["loc"]
        scale = sd_config["std"] if "std" in sd_config else sd_config["scale"]
        return partial(rand_log_normal, loc=loc, scale=scale)
    if sd_config["type"] == "loglogistic":
        loc = sd_config["loc"] if "loc" in sd_config else math.log(sigma_data)
        scale = sd_config["scale"] if "scale" in sd_config else 0.5
        min_value = sd_config["min_value"] if "min_value" in sd_config else 0.0
        max_value = sd_config["max_value"] if "max_value" in sd_config else float("inf")
        return partial(
            rand_log_logistic, loc=loc, scale=scale, min_value=min_value, max_value=max_value
        )
    if sd_config["type"] == "loguniform":
        min_value = sd_config["min_value"] if "min_value" in sd_config else config["sigma_min"]
        max_value = sd_config["max_value"] if "max_value" in sd_config else config["sigma_max"]
        return partial(rand_log_uniform, min_value=min_value, max_value=max_value)
    if sd_config["type"] in {"v-diffusion", "cosine"}:
        min_value = sd_config["min_value"] if "min_value" in sd_config else 1e-3
        max_value = sd_config["max_value"] if "max_value" in sd_config else 1e3
        return partial(
            rand_v_diffusion, sigma_data=sigma_data, min_value=min_value, max_value=max_value
        )
    if sd_config["type"] == "split-lognormal":
        loc = sd_config["mean"] if "mean" in sd_config else sd_config["loc"]
        scale_1 = sd_config["std_1"] if "std_1" in sd_config else sd_config["scale_1"]
        scale_2 = sd_config["std_2"] if "std_2" in sd_config else sd_config["scale_2"]
        return partial(rand_split_log_normal, loc=loc, scale_1=scale_1, scale_2=scale_2)
    raise ValueError("Unknown sample density type")


def rand_log_normal(shape, loc=0.0, scale=1.0, device="cpu", dtype=torch.float32):
    """Draws samples from an lognormal distribution."""
    return (torch.randn(shape, device=device, dtype=dtype) * scale + loc).exp()


def rand_log_logistic(
    shape,
    loc=0.0,
    scale=1.0,
    min_value=0.0,
    max_value=float("inf"),
    device="cpu",
    dtype=torch.float32,
):
    """Draws samples from an optionally truncated log-logistic distribution."""
    min_value = torch.as_tensor(min_value, device=device, dtype=torch.float64)
    max_value = torch.as_tensor(max_value, device=device, dtype=torch.float64)
    min_cdf = min_value.log().sub(loc).div(scale).sigmoid()
    max_cdf = max_value.log().sub(loc).div(scale).sigmoid()
    u = torch.rand(shape, device=device, dtype=torch.float64) * (max_cdf - min_cdf) + min_cdf
    return u.logit().mul(scale).add(loc).exp().to(dtype)


def rand_log_uniform(shape, min_value, max_value, device="cpu", dtype=torch.float32):
    """Draws samples from an log-uniform distribution."""
    min_value = math.log(min_value)
    max_value = math.log(max_value)
    return (
        torch.rand(shape, device=device, dtype=dtype) * (max_value - min_value) + min_value
    ).exp()


def rand_v_diffusion(
    shape, sigma_data=1.0, min_value=0.0, max_value=float("inf"), device="cpu", dtype=torch.float32
):
    """Draws samples from a truncated v-diffusion training timestep distribution."""
    min_cdf = math.atan(min_value / sigma_data) * 2 / math.pi
    max_cdf = math.atan(max_value / sigma_data) * 2 / math.pi
    u = torch.rand(shape, device=device, dtype=dtype) * (max_cdf - min_cdf) + min_cdf
    return torch.tan(u * math.pi / 2) * sigma_data


def rand_split_log_normal(shape, loc, scale_1, scale_2, device="cpu", dtype=torch.float32):
    """Draws samples from a split lognormal distribution."""
    n = torch.randn(shape, device=device, dtype=dtype).abs()
    u = torch.rand(shape, device=device, dtype=dtype)
    n_left = n * -scale_1 + loc
    n_right = n * scale_2 + loc
    ratio = scale_1 / (scale_1 + scale_2)
    return torch.where(u < ratio, n_left, n_right).exp()
